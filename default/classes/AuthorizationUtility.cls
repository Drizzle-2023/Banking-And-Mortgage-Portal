/**********************************************************
@class      AuthorizationUtility
@brief      Provides token issuance, introspection, & revocation
@testClass  AuthorizationUtilityTest
@author     Lee Hildebrand (EMS.Senior Salesforce Developer)
@version    05/11/2017    Lee Hildebrand (EMS.Senior Salesforce Developer) Create class (https://github.com/emsconsulting/encompass/issues/35)
@bug        No known defects.
@todo       None.
@copyright  (c)2017 EMS.  All Rights Reserved. Unauthorized use is prohibited.
***********************************************************/
public class AuthorizationUtility {

    public class token {
        public String access_token;
        public String token_type;
    }

    public class token_introspection {
        public boolean active;
        public string scope;
        public string client_id;
        public string username;
        public string token_type;
        public integer exp;
        //exp is the number of seconds until the token expires (from January 1, 1970 UTC).
        public string sub;
        public string encompass_instance_id;
        public string user_name;
        public string user_key;
        public string encompass_user;
        public string identity_type;
        public string encompass_client_id;
        public string realm_name;
    }

    public class AuthorizationException extends Exception {}

    public static Encompass_Connect_Credential__mdt credential(String userId,String instance) {
        List<Encompass_Connect_Credential__mdt> credentials = null;
        if(!String.isBlank(instance)) {
            credentials =  [SELECT  Username__c,
                    Password__c,
                    Instance_Name__c
            FROM Encompass_Connect_Credential__mdt
            WHERE (Label=:userId AND Instance_Name__c=:instance)];
            if(credentials.size() == 0) {
                // Try and look up for a user Id of Default
                credentials =  [SELECT  Username__c,
                        Password__c,
                        Instance_Name__c
                FROM Encompass_Connect_Credential__mdt
                WHERE (Label='Default' AND Instance_Name__c=:instance)];
            }
        }
        else {
            credentials = [SELECT  Username__c,
                    Password__c,
                    Instance_Name__c
            FROM Encompass_Connect_Credential__mdt
            WHERE Label=:userId];
            if(credentials.size() == 0) {
                credentials = [SELECT  Username__c,
                        Password__c,
                        Instance_Name__c
                FROM Encompass_Connect_Credential__mdt
                WHERE Label='Default'];
            }
        }
        if (credentials.size() == 0) {
            return null;
        }
        return credentials.get(0);
    }

    //
    // **** NOTE ABOUT API KEYS ****
    // Rob Sullivan
    // 2021-06-25
    //
    // The Encompass Client Id and Client Secret are passed in the request header.
    //
    // More than half of the time, the Client Secret generated by Encompass only has a handful of "allowable"
    // special characters. The following characters are confirmed to be "allowable":
    //
    // - &
    // - *
    //
    // Occasionally, the Client Secret contains "problematic" special characters. Some or all of the following
    // characters are problematic:
    //
    // - %
    // - !
    // - ^
    // - #
    //
    // The only way to URL Encode the username and password merged in from the Named Credential is to use the following
    // formula function:
    //
    // {!HTMLENCODE($Credential.Password)}
    //
    // However, this function is unusable for several reasons:
    //
    // 1) The function is only supported in the request body and not in the header. (you can technically pass the
    //    Encompass Client Id and Client Secret in the request body, but that doesn't work for the next 2 reasons)
    // 2) The function doesn't seem to use UTF-8 encoding - it for sure doesn't support all the "problematic" special
    //    chars possible in an Encompass API key.
    // 3) Due to order of operations, other Encoding schemes (such as EncodingUtil.urlEncode) are applied before
    //    the merge field is "merged" so that we encode the tag (e.g. {!$Credential.Password}) rather than the
    //    actual password value.
    //
    // I've only discovered the following workarounds to date:
    //
    // 1) Re-generate a new Encompass Client Secret that doesn't contain the prohibited characters. (may take
    //    several attempts)
    // 2) Manually encode the Client Secret and save the encoded value directly in the Named Credential
    //    password field. You can inspect the raw request body in Postman to obtain the encoded Client Secret
    //
    // Note that none of these problems exist for the Smart Client password, since it is pulled from custom metadata
    // and we can use EncodingUtil.urlEncode to handle all UTF-8 special chars in the password.
    //
    public static token getToken() {
        try {
            Encompass_Connect_Setting_Endpoint__mdt ecse = CalloutUtility.endpoint('Token_Issuance');
            Encompass_Connect_Credential__mdt credential = credential(UserInfo.getUserId(),null);
            HttpRequest req = new HttpRequest();
            req.setEndpoint('callout:Encompass'+ecse.Endpoint__c);
            req.setMethod(ecse.Method__c);
            req.setheader('Content-type', ecse.Content_Type__c);
            //
            // {!$Credential.AuthorizationHeaderValue} contains the Encompass Client Id and Client Secret
            //
            req.setHeader('Authorization', '{!$Credential.AuthorizationMethod} {!$Credential.AuthorizationHeaderValue}');
            req.setTimeout(120000);
            //
            // These are the Encompass Smart Client username and password values from the
            // Encompass_Connect_Credential__mdt custom metadata
            //
            req.setBody('grant_type=' + ecse.Grant_Type__c
                    + '&username=' + EncodingUtil.urlEncode(credential.Username__c, 'UTF-8')
                    + '&password=' + EncodingUtil.urlEncode(credential.Password__c, 'UTF-8'));
            Http h = new Http();
            HttpResponse response = h.send(req);
            if(response.getStatusCode()>299) {
                return null;
            }
            return (token)JSON.deserialize(response.getBody(),  token.class);
        } catch(Exception e) {
            throw new AuthorizationException('The token could not be retrieved by Apex.'+
                        ' \n There was a(n) '+e.getTypeName()+
                        ' type of error stating: \n"'+e.getMessage()+
                        '"\n on line '+e.getLineNumber()+
                        ' when running:  \n'+e.getStackTraceString());
        }
    }

    public static token_introspection tokenIntrospection(token token) {
        try {
            Encompass_Connect_Setting_Endpoint__mdt ecse = +CalloutUtility.endpoint('Token_Introspection');
            HttpRequest req = new HttpRequest();
            req.setEndpoint('callout:Encompass'+ecse.Endpoint__c);
            req.setMethod(ecse.Method__c);
            req.setheader('Content-type', ecse.Content_Type__c);
            req.setHeader('Authorization', '{!$Credential.AuthorizationMethod} {!$Credential.AuthorizationHeaderValue}');
            req.setTimeout(120000);
            req.setBody('token='+EncodingUtil.urlEncode(token.access_token,'UTF-8'));
            return (token_introspection)JSON.createParser(new Http().send(req).getBody()).readValueAs(token_introspection.class);
        } catch(Exception e) {
            throw new AuthorizationException('The token could not be retrieved by Apex.'+
                        ' \n There was a(n) '+e.getTypeName()+
                        ' type of error stating: \n"'+e.getMessage()+
                        '"\n on line '+e.getLineNumber()+
                        ' when running:  \n'+e.getStackTraceString());
        }
    }

    public static string tokenRevocation(token token) {
        try {
            Encompass_Connect_Setting_Endpoint__mdt ecse = +CalloutUtility.endpoint('Token_Revocation');
            HttpRequest req = new HttpRequest();
            req.setEndpoint('callout:Encompass'+ecse.Endpoint__c);
            req.setMethod(ecse.Method__c);
            req.setheader('Content-type', ecse.Content_Type__c);
            req.setHeader('Authorization', '{!$Credential.AuthorizationMethod} {!$Credential.AuthorizationHeaderValue}');
            req.setTimeout(120000);
            req.setBody('token='+EncodingUtil.urlEncode(token.access_token,'UTF-8'));
            HttpResponse response = new Http().send(req);
            return response.getStatusCode()==204 ? 'Token Revoked (Status Code: '+response.getStatusCode()+')' : 'Token Not Revoked (Status Code: '+response.getStatusCode()+')';
        } catch(Exception e) {
            throw new AuthorizationException('The token could not be retrieved by Apex.'+
                        ' \n There was a(n) '+e.getTypeName()+
                        ' type of error stating: \n"'+e.getMessage()+
                        '"\n on line '+e.getLineNumber()+
                        ' when running:  \n'+e.getStackTraceString());
        }
    }
}